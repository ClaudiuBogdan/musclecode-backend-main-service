datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model AlgorithmTemplate {
  id         String   @id @default(uuid())
  title      String
  categories String[]
  summary    String
  lessons    Json     @default("[]") @db.JsonB // Array of lessons stored as JSON
  difficulty String
  level      Int?
  tags       String[]
  files      Json // Array stored as JSON
  userId     String? // Null indicates system template
  parentId   String? // Original template ID if cloned
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  parent          AlgorithmTemplate?    @relation("TemplateClones", fields: [parentId], references: [id])
  clones          AlgorithmTemplate[]   @relation("TemplateClones")
  collections     AlgorithmCollection[]
  userAlgorithms  AlgorithmUserData[]
  dailyAlgorithms DailyAlgorithm[]

  @@index([userId])
  @@index([categories])
  @@index([parentId])
}

model Collection {
  id          String   @id @default(uuid())
  name        String
  description String?
  userId      String? // Null indicates system collection
  parentId    String? // Original collection ID if cloned
  createdAt   DateTime @default(now())

  // Relations
  parent     Collection?           @relation("CollectionClones", fields: [parentId], references: [id])
  clones     Collection[]          @relation("CollectionClones")
  algorithms AlgorithmCollection[]

  @@index([userId])
  @@index([parentId])
}

model AlgorithmCollection {
  algorithmId  String
  collectionId String
  algorithm    AlgorithmTemplate @relation(fields: [algorithmId], references: [id])
  collection   Collection        @relation(fields: [collectionId], references: [id])

  @@id([algorithmId, collectionId])
  @@index([collectionId])
}

model AlgorithmUserData {
  id           String            @id @default(uuid())
  userId       String
  algorithmId  String
  notes        String?
  createdAt    DateTime          @default(now())
  due          DateTime          @default(now()) // Next review date
  scheduleData Json // FSRS scheduling data as JSON
  algorithm    AlgorithmTemplate @relation(fields: [algorithmId], references: [id])
  submissions  Submission[]

  @@unique([userId, algorithmId])
  @@index([userId])
  @@index([due])
}

model Submission {
  id                  String            @id @default(uuid())
  userId              String
  algorithmUserDataId String
  algorithmId         String
  files               Json
  language            String
  timeSpent           Int
  notes               String?
  difficulty          String
  scheduleData        Json // Snapshot of schedule data as JSON string
  createdAt           DateTime          @default(now())
  algorithmUserData   AlgorithmUserData @relation(fields: [algorithmUserDataId], references: [id])

  @@index([userId, algorithmId])
}

model DailyAlgorithm {
  id          String            @id @default(uuid())
  userId      String
  algorithmId String
  date        DateTime
  completed   Boolean           @default(false)
  algorithm   AlgorithmTemplate @relation(fields: [algorithmId], references: [id])
  createdAt   DateTime          @default(now())

  @@unique([userId, algorithmId, date])
  @@index([userId, date])
}

model UserOnboarding {
  id          String       @id @default(uuid())
  userId      String       @unique
  currentStep String // welcome, goals, quiz, summary
  isCompleted Boolean      @default(false)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  goals       UserGoals?
  quizResults QuizResults?

  @@index([userId])
}

model UserGoals {
  id                  String         @id @default(uuid())
  userId              String         @unique
  onboardingId        String         @unique
  onboarding          UserOnboarding @relation(fields: [onboardingId], references: [id])
  studyTime           Int            @default(30) // minutes per day
  selectedCollections String[]       @default([])
  createdAt           DateTime       @default(now())
  updatedAt           DateTime       @updatedAt

  @@index([userId])
}

model QuizResults {
  id           String         @id @default(uuid())
  userId       String         @unique
  onboardingId String         @unique
  onboarding   UserOnboarding @relation(fields: [onboardingId], references: [id])
  answers      Json
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt

  @@index([userId])
}

model ChatThread {
  id          String   @id @default(uuid())
  userId      String
  algorithmId String
  type        String   @default("chat") // chat, hint
  messages    Json     @default("[]") // Array of messages stored as JSON
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
  @@index([algorithmId])
}

// A generic node representing any learning content
model ContentNode {
  id        String        @id @default(uuid())
  type      ContentType
  status    ContentStatus @default(DRAFT)
  body      Json // Markdown, HTML, or structured JSON content
  metadata  Json? // Field to store additional dynamic properties
  userId    String?
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  outgoingLinks      ContentLink[]     @relation("OutgoingLinks")
  incomingLinks      ContentLink[]     @relation("IncomingLinks")
  interactions       InteractionData[]
  tags               Tag[]             @relation("ContentNodeTags")
  nodePermissions    NodePermission[]
  sourceOfPermission NodePermission[]  @relation("SourceOfPermission")

  @@index([userId]) // Optimizes queries filtering by userId
  @@index([type]) // Useful when filtering by content type
}

model ContentLink {
  id       String   @id @default(uuid())
  fromId   String
  toId     String
  linkType LinkType // e.g., REFERENCE, DEPENDENCY, RELATES_TO, EXTENDS
  order    Int      @default(0) // Order of this link relative to others
  metadata Json? // Extra info or weight for the link
  userId   String?

  from ContentNode @relation("OutgoingLinks", fields: [fromId], references: [id])
  to   ContentNode @relation("IncomingLinks", fields: [toId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([fromId, toId, linkType]) // Prevents duplicate links between the same nodes by type
  @@index([fromId, toId])
  @@index([userId]) // Helps when filtering links by user
}

model InteractionData {
  id          String          @id @default(uuid())
  type        InteractionType // e.g., QUIZ, FLASHCARD
  userId      String
  body        Json // Detailed interactive element definition
  nodeId      String
  contentNode ContentNode     @relation(fields: [nodeId], references: [id])
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  @@index([nodeId]) // Optimizes lookups for interactions related to a node
  @@index([userId]) // Optimizes lookups for interactions by user
}

// Stores the calculated effective permission for a user on a node
// This table is populated/updated by the propagation logic
model NodePermission {
  id              String          @id @default(uuid())
  userId          String // User whose effective permission this is
  nodeId          String // The ContentNode this permission applies to
  permissionLevel PermissionLevel // The resulting access level after propagation/overrides
  sourceNodeId    String // The ID of the ContentNode where the relevant ExplicitPermission originated
  isExplicit      Boolean         @default(true) // True if this effective permission comes directly from an ExplicitPermission on this node
  grantingUserId  String // The user who granted the permission

  contentNode ContentNode @relation(fields: [nodeId], references: [id])
  sourceNode  ContentNode @relation("SourceOfPermission", fields: [sourceNodeId], references: [id]) // Relation to the source node
  // Consider adding relations to User models

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, nodeId]) // A user has one effective permission level per node
  @@index([userId, permissionLevel]) // Optimize permission checks
  @@index([nodeId])
  @@index([sourceNodeId]) // Useful for propagation updates
}

enum PermissionLevel {
  NONE // Explicitly denies access (useful for overrides)
  VIEW // Can see the node content
  INTERACT // Can view and interact (e.g., answer quizzes)
  EDIT // Can modify the node content/metadata
  MANAGE // Can grant/revoke permissions on this node and potentially descendants
  OWNER // Full control (Define semantics clearly)
}

// New model to support tagging of content nodes
model Tag {
  id    String        @id @default(uuid())
  name  String        @unique // Ensures tag names are unique
  nodes ContentNode[] @relation("ContentNodeTags")
}

enum ContentStatus {
  DRAFT
  CREATED
  ARCHIVED
}

enum ContentType {
  MODULE // A collection of lessons or other modules
  LESSON
  EXERCISE
  NOTE
  ARTICLE
  CHAT_THREAD
}

enum LinkType {
  REFERENCE
  DEPENDENCY
  RELATES_TO
  EXTENDS
}

enum InteractionType {
  QUIZ
  FLASHCARD
}
